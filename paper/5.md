# 

## 数据结构——链表(linked list)

线性的数据结构,以下是常见操作。插入和删除元素都是O(1)的时间复杂度，查找是O(n)。

-  len() —— 返回链表中数据元素的个数
-  is_empty() —— 若链表为空则返回一个布尔值 true
-  value_at(index) —— 返回第 n 个元素的值（从0开始计算）
-  push_front(value) —— 添加元素到链表的首部
-  pop_front() —— 删除首部元素并返回其值
-  push_back(value) —— 添加元素到链表的尾部
-  pop_back() —— 删除尾部元素并返回其值
-  front() —— 返回首部元素的值
-  back() —— 返回尾部元素的值
-  insert(index, value) —— 插入值到指定的索引，并把当前索引的元素指向到新的元素,
-  erase(index) —— 删除指定索引的节点
-  value_n_from_end(n) —— 返回倒数第 n 个节点的值
-  reverse() —— 逆序链表
-  remove_value(value) —— 删除链表中指定值的第一个元素



## 反转链表

首先想到把链表的指针反转过来，在从头到尾输出就行了，这种思路代码如下

```golang

```



如果不允许修改链表呢，接下来想到要解决这个问题肯定要遍历链表，遍历的顺序是从头到尾，可输出顺序却要从尾到头。也就是说，第一个遍历到的节点最后一个输出，而最后一个遍历到的节点第一个输出。这是典型的“后进先出”。我们可以用栈实现这种顺序。每经过一个节点的时候，把该节点放到一个栈中。当遍历完整个链表后，再从栈顶开始逐个输出节点的值，此时节点的顺序已经反转过来了。这种思路代码如下

```golang

```

既然想到用栈来实现，而递归本质上也就是一个栈结构，于是很自然想到用递归来实现。要实现反过来输出链表，我们每访问到一个节点，先递归输出后面的节点，在输出该节点自身，这样链表输出结果就反过来了。

```golang

```





[完整代码示例:]()

